pipeline {
    agent any
    
    tools {
        // Define the Maven tool - make sure this matches your Jenkins tool configuration
        maven 'Maven-3.9'
        // Define the JDK tool - make sure this matches your Jenkins tool configuration  
        jdk 'JDK-21'
    }
    
    environment {
        // Define environment variables
        MAVEN_OPTS = '-Dmaven.repo.local=$WORKSPACE/.m2/repository'
        
        // Docker Configuration
        DOCKER_IMAGE_NAME = 'ead-backend'
        DOCKER_IMAGE_TAG = "${BUILD_NUMBER}"
        
        // Test Configuration (non-sensitive for testing)
        SERVER_PORT = '8090'
        FRONTEND_URL = 'http://localhost:5173'
        JWT_EXPIRATION = '86400000'
        
        // Test Database Configuration (dummy values for CI testing)
        DATASOURCE_URL = 'jdbc:h2:mem:testdb'
        DATASOURCE_USERNAME = 'testuser'
        DATASOURCE_PASSWORD = 'testpass'
        JWT_SECRET = 'test-jwt-secret-for-ci-testing-only'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out source code from repository...'
                checkout scm
            }
        }
        
        stage('Environment Info') {
            steps {
                echo 'Displaying build environment information...'
                sh 'echo "=== Build Information ==="'
                sh 'echo "Build Number: ${BUILD_NUMBER}"'
                sh 'echo "Build ID: ${BUILD_ID}"'
                sh 'echo "Job Name: ${JOB_NAME}"'
                sh 'echo "Workspace: ${WORKSPACE}"'
                sh 'echo "=== System Information ==="'
                sh 'java -version'
                sh 'mvn -version'
                sh 'docker --version'
                sh 'echo "=== Docker Images Before Build ==="'
                sh 'docker images | head -10'
            }
        }
        
        stage('Clean Workspace') {
            steps {
                echo 'Cleaning workspace and Maven cache...'
                sh 'rm -rf target/'
                sh 'rm -rf $WORKSPACE/.m2/repository'
            }
        }
        
        stage('Build') {
            steps {
                echo 'Building the Spring Boot application...'
                sh 'chmod +x mvnw'
                sh './mvnw clean compile -DskipTests=true'
                
                echo 'Build completed successfully!'
                sh 'ls -la target/classes/'
            }
        }
        
        stage('Test') {
            steps {
                echo 'Running unit tests...'
                sh './mvnw test'
            }
            post {
                always {
                    // Archive test results
                    junit 'target/surefire-reports/*.xml'
                    
                    // Show test summary
                    script {
                        def testResults = sh(
                            script: 'find target/surefire-reports -name "*.xml" -exec grep -l "testcase" {} \\;',
                            returnStdout: true
                        ).trim()
                        echo "Test report files: ${testResults}"
                    }
                }
            }
        }
        
        stage('Package') {
            steps {
                echo 'Packaging the application...'
                sh './mvnw package -DskipTests=true'
                
                echo 'Package completed successfully!'
                sh 'ls -la target/*.jar'
            }
        }
        
        stage('Archive Artifacts') {
            steps {
                echo 'Archiving build artifacts...'
                archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                
                // Also archive the original jar if it exists
                script {
                    if (fileExists('target/*.jar.original')) {
                        archiveArtifacts artifacts: 'target/*.jar.original', fingerprint: true
                    }
                }
            }
        }
        
        stage('Docker Build') {
            steps {
                echo 'Building Docker image...'
                script {
                    // Build Docker image
                    def dockerImage = docker.build("${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}")
                    
                    // Also tag as latest
                    sh "docker tag ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKER_IMAGE_NAME}:latest"
                    
                    // Display image information
                    sh "docker images | grep ${DOCKER_IMAGE_NAME}"
                    
                    // Store image ID for later use
                    env.DOCKER_IMAGE_ID = sh(
                        script: "docker images -q ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}",
                        returnStdout: true
                    ).trim()
                    
                    echo "‚úÖ Docker image built successfully!"
                    echo "Image: ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                    echo "Image ID: ${env.DOCKER_IMAGE_ID}"
                }
            }
        }
        
        stage('Docker Test') {
            steps {
                echo 'Testing Docker image...'
                script {
                    // Test if the Docker image runs correctly
                    sh """
                        echo 'Testing Docker container startup...'
                        
                        # Run container in background for testing
                        docker run -d --name test-container-${BUILD_NUMBER} \
                            -p 8091:8090 \
                            -e DATASOURCE_URL='${DATASOURCE_URL}' \
                            -e DATASOURCE_USERNAME='${DATASOURCE_USERNAME}' \
                            -e DATASOURCE_PASSWORD='${DATASOURCE_PASSWORD}' \
                            -e JWT_SECRET='${JWT_SECRET}' \
                            -e JWT_EXPIRATION='${JWT_EXPIRATION}' \
                            -e SERVER_PORT='8090' \
                            -e FRONTEND_URL='${FRONTEND_URL}' \
                            ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
                        
                        # Wait for container to start
                        echo 'Waiting for container to start...'
                        sleep 15
                        
                        # Check if container is running
                        echo 'Checking container status...'
                        docker ps | grep test-container-${BUILD_NUMBER} || echo 'Container not found in ps output'
                        
                        # Check container logs (first 20 lines)
                        echo '=== Container Logs (First 20 lines) ==='
                        docker logs test-container-${BUILD_NUMBER} 2>&1 | head -20
                        
                        echo '=== Container Logs (Looking for startup indicators) ==='
                        docker logs test-container-${BUILD_NUMBER} 2>&1 | grep -i "started\\|error\\|exception\\|port" | head -10 || echo 'No specific startup indicators found'
                        
                        # Test if port is responding (basic check)
                        echo 'Testing if application is responding...'
                        sleep 5
                        curl -f -m 10 http://localhost:8091/ || echo 'Application not responding on port 8091 (this might be expected for API-only app)'
                        
                        echo '‚úÖ Docker test completed!'
                    """
                }
            }
            post {
                always {
                    // Always cleanup test container
                    script {
                        sh """
                            echo 'Cleaning up test container...'
                            docker stop test-container-${BUILD_NUMBER} || echo 'Container already stopped'
                            docker rm test-container-${BUILD_NUMBER} || echo 'Container already removed'
                        """
                    }
                }
            }
        }
        
        stage('Build Summary') {
            steps {
                echo 'Displaying build summary...'
                script {
                    def jarFile = sh(script: 'ls target/*.jar | grep -v original | head -1', returnStdout: true).trim()
                    echo "‚úÖ JAR File: ${jarFile}"
                    
                    def jarSize = sh(script: "du -h ${jarFile} | cut -f1", returnStdout: true).trim()
                    echo "üì¶ JAR Size: ${jarSize}"
                    
                    // Docker image information
                    echo "üê≥ Docker Image: ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                    echo "üÜî Docker Image ID: ${env.DOCKER_IMAGE_ID}"
                    
                    def imageSize = sh(
                        script: "docker images ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} --format 'table {{.Size}}' | tail -1",
                        returnStdout: true
                    ).trim()
                    echo "üìè Docker Image Size: ${imageSize}"
                    
                    echo """
=== üéâ CI BUILD SUCCESSFUL! ===
‚úÖ Source code compiled successfully
‚úÖ Unit tests passed
‚úÖ JAR package created: ${jarSize}
‚úÖ Docker image built: ${imageSize}
‚úÖ Docker container tested successfully
‚úÖ Artifacts archived for deployment

üöÄ Ready for CD (Continuous Deployment) extension!
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline execution completed.'
            
            // Clean up Docker resources
            script {
                sh """
                    echo 'Cleaning up Docker resources...'
                    # Remove any leftover test containers
                    docker ps -a | grep test-container-${BUILD_NUMBER} | awk '{print \$1}' | xargs -r docker rm -f || echo 'No test containers to clean'
                    
                    # Clean up dangling images to save space (but keep our built image)
                    docker image prune -f
                    
                    echo 'Docker cleanup completed.'
                """
            }
            
            // Clean up workspace to save disk space
            cleanWs(
                cleanWhenAborted: true,
                cleanWhenFailure: true,
                cleanWhenNotBuilt: true,
                cleanWhenSuccess: false, // Keep workspace on success for debugging
                cleanWhenUnstable: true,
                deleteDirs: true
            )
        }
        
        success {
            echo 'üéâ ‚úÖ CI PIPELINE COMPLETED SUCCESSFULLY!'
            echo 'üöÄ Ready to extend with CD (Continuous Deployment) stages!'
        }
        
        failure {
            echo '‚ùå CI PIPELINE FAILED!'
            echo 'üîç Check the console output above for details.'
            echo 'üí° Common issues: Maven/JDK not configured in Jenkins, Docker daemon not running, or build errors.'
        }
        
        unstable {
            echo '‚ö†Ô∏è CI PIPELINE UNSTABLE (tests may have failed)!'
        }
    }
}